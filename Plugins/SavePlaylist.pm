# $Id: SavePlaylist.pm,v 1.1 2003/10/22 20:06:50 dean Exp $
# This code is derived from code with the following copyright message:
#
# SliMP3 Server Copyright (C) 2001 Sean Adams, Slim Devices Inc.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License,
# version 2.

package Plugins::SavePlaylist;

use strict;
use FileHandle;
use Slim::Player::Playlist;
use Slim::Utils::Strings qw (string);
use File::Spec::Functions qw(:ALL);
use POSIX qw(strftime);
use Slim::Utils::Misc;

use vars qw($VERSION);
$VERSION = substr(q$Revision: 1.1 $,10);

my $playlistref;
#my $blacklist=catfile(Slim::Utils::Prefs::get('playlistdir'),'blacklist.m3u');

sub getDisplayName { return string('PLUGIN_SAVE_PLAYLIST'); }

#Set common text strings.  can be placed in strings.txt for language templates.
sub strings { return '
PLUGIN_SAVE_PLAYLIST
	EN	Save Playlist

PLUGIN_PLAYLIST_SAVE
	EN	Press RIGHT again to save playlist as:

PLUGIN_PLAYLIST_AS
	EN	Save current playlist as:

PLUGIN_PLAYLIST_SAVING
	EN	Saving current playlist as:
'
};


# the routines
sub setMode {
	my $client = shift;
	my $push = shift;
	my $playlist = Slim::Buttons::Common::param($client, 'saveplaylist');
	$client->lines(\&lines);
	if ($push ne 'push') {
		Slim::Buttons::Common::popModeRight($client);
	} elsif (defined($playlist) && $playlist ne '__undefined') {
		$playlistref = $playlist;
	} else {
		$playlistref = 'a';
		Slim::Buttons::Common::pushMode($client,'INPUT.Text',
						{'callback' => \&Plugins::SavePlaylist::savePluginCallback
						,'valueRef' => \$playlistref
						,'charsRef' => 'Both'
						,'header' => string('PLUGIN_PLAYLIST_AS')
						,'cursorPos' => 0
						});
	}
}

my %functions = (
	'left' => sub  {
		my $client = shift;
		Slim::Buttons::Common::popModeRight($client);
	},
	'right' => sub  {
		my $client = shift;
		my $playlistfile = $playlistref;
		Slim::Buttons::Common::setMode($client, 'playlist');
		savePlaylist($client,$playlistfile);
	},
	'save' => sub {
		my $client = shift;
		Slim::Buttons::Common::pushModeLeft($client, 'PLUGIN.SavePlaylist');
	},
);

sub lines {
	my $client = shift;

	my $line1 = string('PLUGIN_PLAYLIST_SAVE');
	my $line2 = $playlistref;
	return ($line1, $line2, undef, Slim::Hardware::VFD::symbol('rightarrow'));
}

sub savePlaylist {
	my $client = shift;
	my $playlistname = shift;
	my $playlistref = Slim::Player::Playlist::playList($client);
	my $playlistdir = Slim::Utils::Prefs::get('playlistdir');
	my $playlistfile = catfile($playlistdir,$playlistname . ".m3u");
	Slim::Formats::Parse::writeM3U($playlistref,$playlistfile);
	Slim::Display::Animation::showBriefly($client,string('PLUGIN_PLAYLIST_SAVING'),$playlistname);
}

sub getFunctions {
	return \%functions;
}

sub savePluginCallback {
	my ($client,$type) = @_;
	if ($type eq 'nextChar') {
		my $playlist = Slim::Hardware::VFD::subString($playlistref,0,Slim::Hardware::VFD::lineLength($playlistref)-1);
		Slim::Buttons::Common::pushModeLeft($client,'PLUGIN.SavePlaylist',{'saveplaylist'=> $playlist});
	} elsif ($type eq 'backspace') {
		Slim::Buttons::Common::popModeRight($client);
	} else {
		print "EXIT: $type\n";
		Slim::Display::Animation::bumpRight($client);
	};
}

	#switch ($exitMode) {
	#	case /backspace/
	#		{print "backspace\n"; next}
	#	case /cursor_left/
	#	{print "left\n"; next}
	#	    #Generated when the cursor is requested to move left, and is already at the beginning of the string. 
	#	case /cursor_right/
	#	{print "right\n"; next}
	#	    #Generated when the cursor is requested to move left, and is already at the beginning of the string. 
	#	case /delete/
	#	{print "delete\n"; next}
	#	    #Generated when the delete function is called on the last character in the string. 
	#	case /nextChar/
	#	{print "next\n"; next}
	#	    #Generated when the nextChar function is called and the current character is the right arrow. 
	#	case /scroll_left/
	#	{print "scroll_left\n"; next}
	#	    #Generated when a scroll to the left is requested, but the beginning of the string is already being displayed. 
	#	case /scroll_right/
	#	{print "scroll_right\n"; next}
	#	    #Generated when a scroll to the right is requested, but the last character of the string is already being displayed in the leftmost column of the display. 
	#	case /Other/
	#	{print "other\n"; next}
	#	    #Generated by the exit function where the type is determined by the argument supplied. Usually will be a button name like play or add, but be prepared for anything.
	#}
#};

####################################################################
# Adds a mapping for 'save' function in Now Playing mode.
####################################################################
my %mapping = ('play.hold' => 'save');
sub defaultMap { return \%mapping; }
Slim::Hardware::IR::addModeDefaultMapping('playlist',\%mapping);
my $functref = Slim::Buttons::Playlist::getFunctions();
$functref->{'save'} = $functions{'save'};

1;

__END__
